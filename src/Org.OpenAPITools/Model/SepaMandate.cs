/* 
 * Payment Gateway API Specification.
 *
 * The documentation here is designed to provide all of the technical guidance required to consume and integrate with our APIs for payment processing. To learn more about our APIs please visit https://docs.firstdata.com/org/gateway.
 *
 * The version of the OpenAPI document: 21.1.0.20210122.001
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Org.OpenAPITools.Client.OpenAPIDateConverter;

namespace Org.OpenAPITools.Model
{
    /// <summary>
    /// Model for the SEPA Mandate information.
    /// </summary>
    [DataContract]
    public partial class SepaMandate : IEquatable<SepaMandate>, IValidatableObject
    {
        /// <summary>
        /// Sequence type of the direct debit. This defaults to &#39;SINGLE&#39; if not provided.
        /// </summary>
        /// <value>Sequence type of the direct debit. This defaults to &#39;SINGLE&#39; if not provided.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum TypeEnum
        {
            /// <summary>
            /// Enum SINGLE for value: SINGLE
            /// </summary>
            [EnumMember(Value = "SINGLE")]
            SINGLE = 1,

            /// <summary>
            /// Enum FIRSTCOLLECTION for value: FIRST_COLLECTION
            /// </summary>
            [EnumMember(Value = "FIRST_COLLECTION")]
            FIRSTCOLLECTION = 2,

            /// <summary>
            /// Enum RECURRINGCOLLECTION for value: RECURRING_COLLECTION
            /// </summary>
            [EnumMember(Value = "RECURRING_COLLECTION")]
            RECURRINGCOLLECTION = 3,

            /// <summary>
            /// Enum FINALCOLLECTION for value: FINAL_COLLECTION
            /// </summary>
            [EnumMember(Value = "FINAL_COLLECTION")]
            FINALCOLLECTION = 4

        }

        /// <summary>
        /// Sequence type of the direct debit. This defaults to &#39;SINGLE&#39; if not provided.
        /// </summary>
        /// <value>Sequence type of the direct debit. This defaults to &#39;SINGLE&#39; if not provided.</value>
        [DataMember(Name = "type", EmitDefaultValue = false)]
        public TypeEnum Type { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="SepaMandate" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected SepaMandate() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="SepaMandate" /> class.
        /// </summary>
        /// <param name="reference">Existing mandate reference, managed by merchant. Must match [A-Za-z0-9:?/+(),. -]{1,35} and not start with two slashes (\&quot;//\&quot;). Also known as the mandate ID. (required).</param>
        /// <param name="url">Valid URL pointing to the SEPA mandate (PDF / HTML format recommended). (required).</param>
        /// <param name="signatureDate">Date of mandate signature. (required).</param>
        /// <param name="type">Sequence type of the direct debit. This defaults to &#39;SINGLE&#39; if not provided. (required) (default to TypeEnum.SINGLE).</param>
        public SepaMandate(string reference = default(string), string url = default(string), DateTime signatureDate = default(DateTime), TypeEnum type = TypeEnum.SINGLE)
        {
            // to ensure "reference" is required (not null)
            this.Reference = reference ?? throw new ArgumentNullException("reference is a required property for SepaMandate and cannot be null");
            // to ensure "url" is required (not null)
            this.Url = url ?? throw new ArgumentNullException("url is a required property for SepaMandate and cannot be null");
            // to ensure "signatureDate" is required (not null)
            this.SignatureDate = signatureDate;
            // to ensure "type" is required (not null)
            this.Type = type;
        }

        /// <summary>
        /// Existing mandate reference, managed by merchant. Must match [A-Za-z0-9:?/+(),. -]{1,35} and not start with two slashes (\&quot;//\&quot;). Also known as the mandate ID.
        /// </summary>
        /// <value>Existing mandate reference, managed by merchant. Must match [A-Za-z0-9:?/+(),. -]{1,35} and not start with two slashes (\&quot;//\&quot;). Also known as the mandate ID.</value>
        [DataMember(Name = "reference", EmitDefaultValue = false)]
        public string Reference { get; set; }

        /// <summary>
        /// Valid URL pointing to the SEPA mandate (PDF / HTML format recommended).
        /// </summary>
        /// <value>Valid URL pointing to the SEPA mandate (PDF / HTML format recommended).</value>
        [DataMember(Name = "url", EmitDefaultValue = false)]
        public string Url { get; set; }

        /// <summary>
        /// Date of mandate signature.
        /// </summary>
        /// <value>Date of mandate signature.</value>
        [DataMember(Name = "signatureDate", EmitDefaultValue = false)]
        [JsonConverter(typeof(OpenAPIDateConverter))]
        public DateTime SignatureDate { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class SepaMandate {\n");
            sb.Append("  Reference: ").Append(Reference).Append("\n");
            sb.Append("  Url: ").Append(Url).Append("\n");
            sb.Append("  SignatureDate: ").Append(SignatureDate).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as SepaMandate);
        }

        /// <summary>
        /// Returns true if SepaMandate instances are equal
        /// </summary>
        /// <param name="input">Instance of SepaMandate to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(SepaMandate input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Reference == input.Reference ||
                    (this.Reference != null &&
                    this.Reference.Equals(input.Reference))
                ) && 
                (
                    this.Url == input.Url ||
                    (this.Url != null &&
                    this.Url.Equals(input.Url))
                ) && 
                (
                    this.SignatureDate == input.SignatureDate ||
                    (this.SignatureDate != null &&
                    this.SignatureDate.Equals(input.SignatureDate))
                ) && 
                (
                    this.Type == input.Type ||
                    (this.Type != null &&
                    this.Type.Equals(input.Type))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Reference != null)
                    hashCode = hashCode * 59 + this.Reference.GetHashCode();
                if (this.Url != null)
                    hashCode = hashCode * 59 + this.Url.GetHashCode();
                if (this.SignatureDate != null)
                    hashCode = hashCode * 59 + this.SignatureDate.GetHashCode();
                if (this.Type != null)
                    hashCode = hashCode * 59 + this.Type.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Reference (string) maxLength
            if(this.Reference != null && this.Reference.Length > 35)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Reference, length must be less than 35.", new [] { "Reference" });
            }

            // Reference (string) pattern
            Regex regexReference = new Regex(@"[A-Za-z0-9:?\/+(),. -]{1,35}", RegexOptions.CultureInvariant);
            if (false == regexReference.Match(this.Reference).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Reference, must match a pattern of " + regexReference, new [] { "Reference" });
            }

            // Url (string) maxLength
            if(this.Url != null && this.Url.Length > 100)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Url, length must be less than 100.", new [] { "Url" });
            }

            // Url (string) pattern
            Regex regexUrl = new Regex(@"^(?!\\s*$).+", RegexOptions.CultureInvariant);
            if (false == regexUrl.Match(this.Url).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Url, must match a pattern of " + regexUrl, new [] { "Url" });
            }

            yield break;
        }
    }
}
